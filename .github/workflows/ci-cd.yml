name: ProdReady_Infra CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 875486186130
  ECR_REGISTRY: 875486186130.dkr.ecr.us-east-1.amazonaws.com
  BACKEND_REPOSITORY: prodready-infra-api
  FRONTEND_REPOSITORY: prodready-infra-ui
  ECS_CLUSTER: prodready-infra-cluster-staging
  ECS_BACKEND_SERVICE: prodready-infra-backend-service-staging
  ECS_FRONTEND_SERVICE: prodready-infra-frontend-service-staging
  ENVIRONMENT: staging  # Add this line

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Force unlock Terraform state
        run: |
          cd terraform
          echo "üîì Force unlocking Terraform state..."
          terraform force-unlock -force ef4b274e-0c2c-cbf5-2ec5-f8e81ffd4e34 2>/dev/null || echo "No lock with this ID or already cleared"
        continue-on-error: true

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -var-file="environments/staging.tfvars"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Clear stale Terraform locks
        run: |
          cd terraform
          echo "üîì Clearing any stale Terraform locks..."
          if terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep -q "Lock Info:"; then
            LOCK_ID=$(terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep "ID:" | awk '{print $2}' | head -1)
            echo "Detected lock ID: $LOCK_ID"
            terraform force-unlock -force "$LOCK_ID" 2>/dev/null || echo "Could not unlock or already cleared"
          else
            echo "No locks detected"
          fi
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Build and push Backend image
        id: backend_image
        run: |
          cd api
          echo "üèóÔ∏è Building backend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:latest .
          
          echo "üì§ Pushing backend image..."
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:latest
          echo "‚úÖ Backend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Frontend image
        id: frontend_image
        run: |
          cd ui
          echo "üèóÔ∏è Building frontend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest .
          
          echo "üì§ Pushing frontend image..."
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest
          echo "‚úÖ Frontend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      
      - name: Update Backend Task Definition
        id: backend_task_def
        run: |
          echo "üìù Updating backend task definition with new image..."
          
          # Get the correct task definition family name from Terraform output or construct it
          TASK_FAMILY="${{ env.ECS_CLUSTER }%-cluster-*}-backend-task-${{ env.ENVIRONMENT }}"
          # Simpler: just use the expected naming convention
          TASK_FAMILY="prodready-infra-backend-task-staging"
          
          echo "Looking for task definition family: $TASK_FAMILY"
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --region ${{ env.AWS_REGION }} 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to get task definition: $TASK_DEF"
            echo "Available task definitions:"
            aws ecs list-task-definitions --region ${{ env.AWS_REGION }} | grep backend
            exit 1
          fi
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "${{ steps.backend_image.outputs.image_uri }}" '
            .taskDefinition |
            .containerDefinitions[0].image = $IMAGE |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION }})
          
          NEW_REVISION=$(echo "$NEW_TASK_INFO" | jq -r '.taskDefinition.revision')
          echo "‚úÖ New backend task definition revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "family=$TASK_FAMILY" >> $GITHUB_OUTPUT

      - name: Update Frontend Task Definition
        id: frontend_task_def
        run: |
          echo "üìù Updating frontend task definition with new image..."
          
          TASK_FAMILY="prodready-infra-frontend-task-staging"
          echo "Looking for task definition family: $TASK_FAMILY"
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --region ${{ env.AWS_REGION }} 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to get task definition: $TASK_DEF"
            echo "Available task definitions:"
            aws ecs list-task-definitions --region ${{ env.AWS_REGION }} | grep frontend
            exit 1
          fi
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "${{ steps.frontend_image.outputs.image_uri }}" '
            .taskDefinition |
            .containerDefinitions[0].image = $IMAGE |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION }})
          
          NEW_REVISION=$(echo "$NEW_TASK_INFO" | jq -r '.taskDefinition.revision')
          echo "‚úÖ New frontend task definition revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "family=$TASK_FAMILY" >> $GITHUB_OUTPUT

      - name: Update ECS Services
        run: |
          echo "üîÑ Updating ECS services with new task definitions..."
          
          # Update backend service with new task definition
          echo "Updating backend service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_BACKEND_SERVICE }} \
            --task-definition "${{ steps.backend_task_def.outputs.family }}:${{ steps.backend_task_def.outputs.revision }}" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          # Update frontend service with new task definition
          echo "Updating frontend service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_FRONTEND_SERVICE }} \
            --task-definition "${{ steps.frontend_task_def.outputs.family }}:${{ steps.frontend_task_def.outputs.revision }}" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ ECS services updated with new task definitions"

      - name: Wait for Deployment
        run: |
          echo "‚è≥ Waiting for services to stabilize..."
          
          # Wait for backend (with timeout)
          echo "Waiting for backend service..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_BACKEND_SERVICE }} \
            --region ${{ env.AWS_REGION }} && echo "‚úÖ Backend stable" || echo "‚ö†Ô∏è Backend wait timeout"

          # Wait for frontend (with timeout)
          echo "Waiting for frontend service..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_FRONTEND_SERVICE }} \
            --region ${{ env.AWS_REGION }} && echo "‚úÖ Frontend stable" || echo "‚ö†Ô∏è Frontend wait timeout"
          
          # Verify running tasks are using new task definitions
          echo ""
          echo "üìã Verifying task definitions..."
          
          # Backend verification
          BACKEND_TASKS=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_BACKEND_SERVICE }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$BACKEND_TASKS" != "None" ] && [ -n "$BACKEND_TASKS" ]; then
            BACKEND_TASK_DEF=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --tasks $BACKEND_TASKS \
              --query 'tasks[0].taskDefinitionArn' \
              --output text \
              --region ${{ env.AWS_REGION }})
            echo "Backend running task definition: $BACKEND_TASK_DEF"
            
            BACKEND_IMAGE=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --tasks $BACKEND_TASKS \
              --query 'tasks[0].containers[0].image' \
              --output text \
              --region ${{ env.AWS_REGION }})
            echo "Backend container image: $BACKEND_IMAGE"
            echo "Expected: ${{ steps.backend_image.outputs.image_uri }}"
          else
            echo "‚ö†Ô∏è No running backend tasks found"
          fi
          
          # Frontend verification
          FRONTEND_TASKS=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_FRONTEND_SERVICE }} \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$FRONTEND_TASKS" != "None" ] && [ -n "$FRONTEND_TASKS" ]; then
            FRONTEND_TASK_DEF=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --tasks $FRONTEND_TASKS \
              --query 'tasks[0].taskDefinitionArn' \
              --output text \
              --region ${{ env.AWS_REGION }})
            echo "Frontend running task definition: $FRONTEND_TASK_DEF"
            
            FRONTEND_IMAGE=$(aws ecs describe-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --tasks $FRONTEND_TASKS \
              --query 'tasks[0].containers[0].image' \
              --output text \
              --region ${{ env.AWS_REGION }})
            echo "Frontend container image: $FRONTEND_IMAGE"
            echo "Expected: ${{ steps.frontend_image.outputs.image_uri }}"
          else
            echo "‚ö†Ô∏è No running frontend tasks found"
          fi

      - name: Verify Container Images
        run: |
          echo "üîç Verifying container images in running tasks..."
          
          # Check backend container image
          BACKEND_TASKS=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_BACKEND_SERVICE \
            --query 'taskArns[0]' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$BACKEND_TASKS" != "None" ]; then
            BACKEND_IMAGE=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $BACKEND_TASKS \
              --query 'tasks[0].containers[0].image' \
              --output text \
              --region ${{ env.AWS_REGION }})
            echo "Backend container image: $BACKEND_IMAGE"
            echo "Expected: ${{ steps.backend_image.outputs.image_uri }}"
            
            if [ "$BACKEND_IMAGE" != "${{ steps.backend_image.outputs.image_uri }}" ]; then
              echo "‚ö†Ô∏è WARNING: Backend image mismatch!"
            else
              echo "‚úÖ Backend image verified"
            fi
          fi

      - name: Health Check
        run: |
          echo "üè• Running health checks..."
          HEALTH_URL="http://prodready-infra-alb-staging-212250592.us-east-1.elb.amazonaws.com/api/health"
          echo "Health check URL: $HEALTH_URL"

          echo "üåê Checking API health endpoint..."
          success=false
          for i in {1..30}; do
            echo "Attempt $i/30: Checking $HEALTH_URL"
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 "$HEALTH_URL" || echo "000")
            echo "HTTP Status: $RESPONSE"
            
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Health check passed!"
              # Show response body
              curl -s "$HEALTH_URL" | jq '.' || curl -s "$HEALTH_URL"
              success=true
              break
            else
              echo "‚è≥ Health check failed (HTTP $RESPONSE), retrying in 15 seconds..."
              
              # Show some debug info every 5 attempts
              if [ $((i % 5)) -eq 0 ]; then
                echo ""
                echo "üìã Recent backend task events:"
                aws ecs describe-services \
                  --cluster $ECS_CLUSTER \
                  --services $ECS_BACKEND_SERVICE \
                  --query 'services[0].events[0:3].[message]' \
                  --output text \
                  --region ${{ env.AWS_REGION }} || true
                echo ""
              fi
              
              sleep 15
            fi
          done

          if [ "$success" != "true" ]; then
            echo "‚ùå Health check failed after 30 attempts"
            echo ""
            echo "üîç Detailed diagnostics:"
            echo "======================="
            
            # Get CloudWatch logs
            echo ""
            echo "üìã Recent backend logs (last 20 lines):"
            LOG_GROUP="/ecs/prodready-infra-backend-staging"
            LATEST_STREAM=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 1 \
              --query 'logStreams[0].logStreamName' \
              --output text \
              --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
            
            if [ -n "$LATEST_STREAM" ] && [ "$LATEST_STREAM" != "None" ]; then
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --limit 20 \
                --region ${{ env.AWS_REGION }} \
                --query 'events[*].message' \
                --output text || echo "Could not fetch logs"
            else
              echo "No log streams found"
            fi
            
            echo ""
            echo "üìã Backend service events (last 10):"
            aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_BACKEND_SERVICE \
              --query 'services[0].events[0:10].[message,createdAt]' \
              --output table \
              --region ${{ env.AWS_REGION }} || true
            
            echo ""
            echo "üìã Target health:"
            BACKEND_TG=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_BACKEND_SERVICE \
              --query 'services[0].loadBalancers[0].targetGroupArn' \
              --output text \
              --region ${{ env.AWS_REGION }} || true)
            
            if [ "$BACKEND_TG" != "None" ]; then
              aws elbv2 describe-target-health \
                --target-group-arn "$BACKEND_TG" \
                --output table \
                --region ${{ env.AWS_REGION }} || true
            fi
            
            exit 1
          fi

      - name: Deployment Summary
        if: always()
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "Region: $AWS_REGION"
          echo "Commit: $GITHUB_SHA"
          echo ""
          if [ "${{ steps.apply.outcome }}" == "success" ]; then
            echo "Status: ‚úÖ Successful"
          else
            echo "Status: ‚ùå Failed"
          fi

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-deploy]
    if: ${{ always() }}
    
    steps:
      - name: Notify Success
        if: ${{ needs.build-and-deploy.result == 'success' }}
        run: echo "üéâ Deployment Successful!"

      - name: Notify Failure
        if: ${{ needs.build-and-deploy.result == 'failure' }}
        run: |
          echo "‚ùå Deployment Failed!"
          exit 1
