name: ProdReady_Infra CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 875486186130
  ECR_REGISTRY: 875486186130.dkr.ecr.us-east-1.amazonaws.com
  BACKEND_REPOSITORY: prodready-infra-api
  FRONTEND_REPOSITORY: prodready-infra-ui
  ECS_CLUSTER: prodready-infra-cluster-staging
  ECS_BACKEND_SERVICE: prodready-infra-backend-service-staging
  ECS_FRONTEND_SERVICE: prodready-infra-frontend-service-staging
  ENVIRONMENT: staging

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Force unlock Terraform state
        run: |
          cd terraform
          echo "ðŸ”“ Force unlocking Terraform state..."
          terraform force-unlock -force ef4b274e-0c2c-cbf5-2ec5-f8e81ffd4e34 2>/dev/null || echo "No lock with this ID or already cleared"
        continue-on-error: true

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -var-file="environments/staging.tfvars"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Clear stale Terraform locks
        run: |
          cd terraform
          echo "ðŸ”“ Clearing any stale Terraform locks..."
          if terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep -q "Lock Info:"; then
            LOCK_ID=$(terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep "ID:" | awk '{print $2}' | head -1)
            echo "Detected lock ID: $LOCK_ID"
            terraform force-unlock -force "$LOCK_ID" 2>/dev/null || echo "Could not unlock or already cleared"
          else
            echo "No locks detected"
          fi
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Build and push Backend image
        id: backend_image
        run: |
          cd api
          echo "ðŸ—ï¸ Building backend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:latest .
          
          echo "ðŸ“¤ Pushing backend image..."
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:latest
          echo "âœ… Backend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Frontend image
        id: frontend_image
        run: |
          cd ui
          echo "ðŸ—ï¸ Building frontend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest .
          
          echo "ðŸ“¤ Pushing frontend image..."
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest
          echo "âœ… Frontend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        id: apply
        run: |
          cd terraform
          echo "ðŸš€ Applying Terraform changes..."
          terraform apply -auto-approve -var-file="environments/staging.tfvars"
          echo "âœ… Infrastructure deployment complete"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Get Terraform Outputs
        id: tf_outputs
        run: |
          cd terraform
          echo "ðŸ“‹ Getting Terraform outputs..."
          
          # Try to get outputs, use defaults if they don't exist
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "prodready-infra-cluster-staging")
          BACKEND_SERVICE=$(terraform output -raw backend_service_name 2>/dev/null || echo "prodready-infra-backend-service-staging")
          FRONTEND_SERVICE=$(terraform output -raw frontend_service_name 2>/dev/null || echo "prodready-infra-frontend-service-staging")
          
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "backend_service=$BACKEND_SERVICE" >> $GITHUB_OUTPUT
          echo "frontend_service=$FRONTEND_SERVICE" >> $GITHUB_OUTPUT
          
          echo "Cluster: $CLUSTER_NAME"
          echo "Backend Service: $BACKEND_SERVICE"
          echo "Frontend Service: $FRONTEND_SERVICE"
        continue-on-error: false

      # âœ… NEW STEP: Render task definition with environment variables
      - name: Render Backend Task Definition
        id: backend_task_def_render
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: api/task-definition.json
          container-name: prodready-infra-backend
          image: ${{ steps.backend_image.outputs.image_uri }}
          environment-variables: |
            PORT=8080
            NODE_ENV=production
            POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            EMAIL=${{ secrets.EMAIL }}
            APP_PASSWORD=${{ secrets.APP_PASSWORD }}
            EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}
            ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
            PROCUREMENT_EMAIL=${{ secrets.PROCUREMENT_EMAIL }}
            FINANCE_EMAIL=${{ secrets.FINANCE_EMAIL }}
            ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
            DEFAULT_USER_PASSWORD=${{ secrets.DEFAULT_USER_PASSWORD }}
            FRONTEND_URL=${{ vars.FRONTEND_URL }}
            FRONTEND_URL_PROD=${{ vars.FRONTEND_URL_PROD }}
            API_BASE_URL=${{ vars.API_BASE_URL }}
            API_BASE_URL_PROD=${{ vars.API_BASE_URL_PROD }}

      # âœ… NEW STEP: Render frontend task definition
      - name: Render Frontend Task Definition
        id: frontend_task_def_render
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ui/task-definition.json
          container-name: prodready-infra-frontend
          image: ${{ steps.frontend_image.outputs.image_uri }}
          environment-variables: |
            NODE_ENV=production
            REACT_APP_API_URL=${{ vars.API_BASE_URL }}

      # âœ… NEW STEP: Deploy backend with rendered task definition
      - name: Deploy Backend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.backend_task_def_render.outputs.task-definition }}
          service: prodready-infra-backend-service-staging
          cluster: prodready-infra-cluster-staging
          wait-for-service-stability: false  # <-- CHANGED

      # âœ… NEW STEP: Deploy frontend with rendered task definition
      - name: Deploy Frontend to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.frontend_task_def_render.outputs.task-definition }}
          service: ${{ steps.tf_outputs.outputs.frontend_service }}
          cluster: ${{ steps.tf_outputs.outputs.cluster_name }}
          wait-for-service-stability: true

      - name: Health Check
        run: |
          echo "ðŸ¥ Running health checks..."
          
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names prodready-infra-alb-staging \
            --query 'LoadBalancers[0].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "Load Balancer: $ALB_DNS"
          
          success=false
          for i in {1..30}; do
            echo "Health check $i/30..."
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 "http://$ALB_DNS/api/health" || echo "000")
            echo "HTTP Status: $RESPONSE"
            
            if [ "$RESPONSE" = "200" ]; then
              echo "âœ… Health check passed!"
              success=true
              break
            elif [ $i -eq 30 ]; then
              echo "âŒ Health check failed after 30 attempts"
              exit 1
            else
              echo "â³ Retrying in 15 seconds..."
              sleep 15
            fi
          done

      - name: Deployment Summary
        if: always()
        run: |
          echo "ðŸ“Š Deployment Summary"
          echo "===================="
          echo "Region: ${{ env.AWS_REGION }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Commit: ${GITHUB_SHA:0:7}"
          echo "Backend Image: ${{ steps.backend_image.outputs.image_tag }}"
          echo "Frontend Image: ${{ steps.frontend_image.outputs.image_tag }}"
          echo ""
          if [ "${{ steps.apply.outcome }}" == "success" ]; then
            echo "Status: âœ… Successful"
          else
            echo "Status: âŒ Failed"
          fi

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-deploy]
    if: ${{ always() }}
    
    steps:
      - name: Notify Success
        if: ${{ needs.build-and-deploy.result == 'success' }}
        run: echo "ðŸŽ‰ Deployment Successful!"

      - name: Notify Failure
        if: ${{ needs.build-and-deploy.result == 'failure' }}
        run: |
          echo "âŒ Deployment Failed!"
          exit 1