name: ProdReady_Infra CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 875486186130
  ECR_REGISTRY: 875486186130.dkr.ecr.us-east-1.amazonaws.com
  BACKEND_REPOSITORY: prodready-infra-api
  FRONTEND_REPOSITORY: prodready-infra-ui
  ECS_CLUSTER: prodready-infra-cluster-staging
  ECS_BACKEND_SERVICE: prodready-infra-backend-service-staging
  ECS_FRONTEND_SERVICE: prodready-infra-frontend-service-staging

jobs:
  # Terraform plan for PRs
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Clear any stale locks
        run: |
          cd terraform
          echo "üîì Checking for stale Terraform locks..."
          
          if terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep -q "Lock Info:"; then
            LOCK_ID=$(terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep "ID:" | awk '{print $2}' | head -1)
            echo "Found lock ID: $LOCK_ID, attempting to unlock..."
            terraform force-unlock -force "$LOCK_ID" 2>/dev/null || echo "Could not unlock or no lock exists"
          else
            echo "No locks detected"
          fi
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Smart ECR State Sync
        run: |
          cd terraform
          echo "üîÑ Smart ECR State Synchronization"
          echo "=================================="
          
          # CRITICAL: The resource path MUST match your for_each key format
          # Since you use: for_each = toset(var.repositories)
          # The path is: module.ecr.aws_ecr_repository.repos["repo-name"]
          
          safe_import() {
            local repo_name=$1
            # This is the CORRECT format for toset(var.repositories)
            local resource_path='module.ecr.aws_ecr_repository.repos["'$repo_name'"]'
            
            echo ""
            echo "üì¶ Processing: $repo_name"
            echo "Resource path: $resource_path"
            
            # Check if exists in AWS
            if aws ecr describe-repositories --repository-names "$repo_name" --region $AWS_REGION >/dev/null 2>&1; then
              echo "  ‚úÖ $repo_name exists in AWS"
              
              # Check if in Terraform state
              if terraform state list 2>/dev/null | grep -qF "$resource_path"; then
                echo "  ‚úÖ Already in Terraform state - SKIP"
                return 0
              else
                echo "  üì• Importing to Terraform state..."
                if terraform import "$resource_path" "$repo_name" 2>&1 | tee /tmp/import_${repo_name}.log; then
                  echo "  ‚úÖ Import successful"
                  return 0
                else
                  if grep -q "Resource already managed\|already exists in the state" /tmp/import_${repo_name}.log; then
                    echo "  ‚úÖ Already managed"
                    return 0
                  else
                    echo "  ‚ö†Ô∏è Import failed"
                    cat /tmp/import_${repo_name}.log
                    return 1
                  fi
                fi
              fi
            else
              echo "  ‚ÑπÔ∏è Will be created by Terraform"
              return 0
            fi
          }
          
          # Process repositories
          safe_import "$BACKEND_REPOSITORY"
          safe_import "$FRONTEND_REPOSITORY"
          
          echo ""
          echo "üìã Current ECR resources in Terraform state:"
          terraform state list | grep ecr_repository || echo "No ECR repositories in state yet"
          echo ""
          echo "‚úÖ State sync completed"
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -refresh=true -var-file="environments/staging.tfvars" -no-color
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

  # Build and push images (only on main branch)
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Clear stale Terraform locks
        run: |
          cd terraform
          echo "üîì Clearing any stale Terraform locks..."
          
          if terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep -q "Lock Info:"; then
            LOCK_ID=$(terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep "ID:" | awk '{print $2}' | head -1)
            echo "Detected lock ID: $LOCK_ID"
            terraform force-unlock -force "$LOCK_ID" 2>/dev/null || echo "Could not unlock or already cleared"
          else
            echo "No locks detected"
          fi
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Enhanced ECR State Synchronization
        run: |
          cd terraform
          echo "üöÄ Enhanced ECR State Synchronization"
          echo "====================================="
          
          validate_and_sync_ecr() {
            local repo_name=$1
            # CRITICAL: Correct resource path for toset(var.repositories)
            local resource_path='module.ecr.aws_ecr_repository.repos["'$repo_name'"]'
            
            echo ""
            echo "üîç Validating: $repo_name"
            echo "Resource: $resource_path"
            
            # Check AWS
            AWS_EXISTS=false
            if aws ecr describe-repositories --repository-names "$repo_name" --region $AWS_REGION >/dev/null 2>&1; then
              AWS_EXISTS=true
              REPO_URI=$(aws ecr describe-repositories --repository-names "$repo_name" --region $AWS_REGION --query 'repositories[0].repositoryUri' --output text)
              echo "  ‚úÖ Repository exists in AWS: $REPO_URI"
            else
              echo "  ‚ÑπÔ∏è Repository does not exist in AWS (will be created)"
            fi
            
            # Check Terraform state (using grep -F for exact match)
            STATE_EXISTS=false
            if terraform state list 2>/dev/null | grep -qF "$resource_path"; then
              STATE_EXISTS=true
              echo "  ‚úÖ Resource exists in Terraform state"
            else
              echo "  ‚ö†Ô∏è Resource missing from Terraform state"
            fi
            
            # Import if needed
            if [ "$AWS_EXISTS" = true ] && [ "$STATE_EXISTS" = false ]; then
              echo "  üîÑ Importing to Terraform state..."
              
              for attempt in 1 2 3; do
                echo "  üì• Import attempt $attempt/3..."
                IMPORT_OUTPUT=$(terraform import "$resource_path" "$repo_name" 2>&1)
                IMPORT_EXIT=$?
                
                if [ $IMPORT_EXIT -eq 0 ]; then
                  echo "  ‚úÖ Import successful"
                  
                  # Verify import
                  if terraform state list 2>/dev/null | grep -qF "$resource_path"; then
                    echo "  ‚úÖ Verified in state"
                    
                    # Refresh to sync attributes
                    echo "  üîÑ Refreshing state..."
                    terraform refresh -target="$resource_path" -var-file="environments/staging.tfvars" >/dev/null 2>&1 || true
                    echo "  ‚úÖ State refreshed"
                    return 0
                  fi
                else
                  if echo "$IMPORT_OUTPUT" | grep -q "Resource already managed\|already exists in the state"; then
                    echo "  ‚úÖ Already managed"
                    return 0
                  elif echo "$IMPORT_OUTPUT" | grep -q "does not exist"; then
                    echo "  ‚ÑπÔ∏è Will be created by Terraform"
                    return 0
                  else
                    echo "  ‚ö†Ô∏è Attempt $attempt failed"
                    if [ $attempt -lt 3 ]; then
                      sleep 2
                    fi
                  fi
                fi
              done
              
              echo "  ‚ö†Ô∏è Import failed after 3 attempts"
              echo "  ‚ÑπÔ∏è Will attempt to handle during apply"
              
            elif [ "$AWS_EXISTS" = true ] && [ "$STATE_EXISTS" = true ]; then
              echo "  ‚úÖ Perfect sync - refreshing state..."
              terraform refresh -target="$resource_path" -var-file="environments/staging.tfvars" >/dev/null 2>&1 || true
              echo "  ‚úÖ State refreshed"
            fi
            
            return 0
          }
          
          # Process both repositories
          validate_and_sync_ecr "$BACKEND_REPOSITORY"
          validate_and_sync_ecr "$FRONTEND_REPOSITORY"
          
          echo ""
          echo "üìä Final State Summary:"
          echo "======================="
          echo ""
          echo "Terraform ECR Resources:"
          terraform state list | grep ecr_repository || echo "  No ECR repositories in state"
          
          echo ""
          echo "AWS ECR Repositories:"
          aws ecr describe-repositories --region $AWS_REGION --query 'repositories[].repositoryName' --output table 2>/dev/null || echo "  Could not list"
          
          echo ""
          echo "‚úÖ Sync completed"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Build and push Backend image
        run: |
          cd api
          echo "üèóÔ∏è Building backend image..."
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:$GITHUB_SHA .
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:latest .
          
          echo "üì§ Pushing backend image..."
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:$GITHUB_SHA
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:latest
          echo "‚úÖ Backend image pushed"

      - name: Build and push Frontend image
        run: |
          cd ui
          echo "üèóÔ∏è Building frontend image..."
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:$GITHUB_SHA .
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest .
          
          echo "üì§ Pushing frontend image..."
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:$GITHUB_SHA
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest
          echo "‚úÖ Frontend image pushed"

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform
          echo "üìù Running Terraform plan..."
          
          # Clear locks
          terraform force-unlock -force fb45a5bc-a2cf-323f-e57b-0432c53495cf 2>/dev/null || true
          
          # Plan with refresh to pick up imported state
          terraform plan -refresh=true -var-file="environments/staging.tfvars" -out=staging.tfplan -no-color
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Terraform Apply
        id: apply
        run: |
          cd terraform
          echo "üöÄ Applying Terraform changes..."
          
          # Clear any stale locks
          terraform force-unlock -force fb45a5bc-a2cf-323f-e57b-0432c53495cf 2>/dev/null || echo "No lock to clear"
          
          # Refresh state to ensure it includes imported ECR repositories
          echo "üîÑ Refreshing Terraform state before apply..."
          terraform refresh -var-file="environments/staging.tfvars" >/dev/null 2>&1 || true
          
          # Check if plan file exists
          if [ -f staging.tfplan ]; then
            echo "Applying saved plan..."
            terraform apply -auto-approve staging.tfplan 2>&1 | tee /tmp/apply_output.log
            APPLY_EXIT=${PIPESTATUS[0]}
            
            if [ $APPLY_EXIT -ne 0 ]; then
              # Check for ECR already exists error
              if grep -q "RepositoryAlreadyExistsException" /tmp/apply_output.log; then
                echo ""
                echo "‚ùå ECR repository already exists error detected!"
                echo "üîç This indicates a mismatch between Terraform state and AWS."
                echo ""
                echo "üìã Current Terraform state (ECR resources):"
                terraform state list | grep ecr || echo "No ECR repositories in state"
                echo ""
                echo "‚òÅÔ∏è AWS ECR repositories:"
                aws ecr describe-repositories --region $AWS_REGION --query 'repositories[].repositoryName' --output text
                echo ""
                echo "üîÑ Attempting to re-sync state and re-apply..."
                
                # Re-run sync for both repositories
                for REPO in "$BACKEND_REPOSITORY" "$FRONTEND_REPOSITORY"; do
                  RESOURCE_PATH="module.ecr.aws_ecr_repository.repos[\"$REPO\"]"
                  if aws ecr describe-repositories --repository-names "$REPO" --region $AWS_REGION >/dev/null 2>&1; then
                    if ! terraform state list 2>/dev/null | grep -qF "$RESOURCE_PATH"; then
                      echo "  üì• Importing $REPO to Terraform state..."
                      terraform import "$RESOURCE_PATH" "$REPO" || echo "Import failed for $REPO"
                    fi
                  fi
                done
                
                # Refresh state again
                terraform refresh -var-file="environments/staging.tfvars" >/dev/null 2>&1 || true
                
                # Retry apply without the plan file
                echo "üîÑ Retrying apply without plan file..."
                terraform apply -auto-approve -var-file="environments/staging.tfvars" 2>&1 | tee /tmp/retry_apply_output.log
                RETRY_EXIT=${PIPESTATUS[0]}
                
                if [ $RETRY_EXIT -ne 0 ]; then
                  echo "‚ùå Retry failed!"
                  cat /tmp/retry_apply_output.log
                  exit 1
                fi
              else
                # Different error, fail immediately
                cat /tmp/apply_output.log
                exit $APPLY_EXIT
              fi
            fi
          else
            echo "‚ö†Ô∏è Plan file not found, performing direct apply..."
            terraform apply -auto-approve -var-file="environments/staging.tfvars" 2>&1 | tee /tmp/apply_output.log
            APPLY_EXIT=${PIPESTATUS[0]}
            
            if [ $APPLY_EXIT -ne 0 ]; then
              if grep -q "RepositoryAlreadyExistsException" /tmp/apply_output.log; then
                echo ""
                echo "‚ùå ECR repository already exists error detected!"
                echo "üîç Re-running import and retrying apply..."
                
                # Re-run sync for both repositories
                for REPO in "$BACKEND_REPOSITORY" "$FRONTEND_REPOSITORY"; do
                  RESOURCE_PATH="module.ecr.aws_ecr_repository.repos[\"$REPO\"]"
                  if aws ecr describe-repositories --repository-names "$REPO" --region $AWS_REGION >/dev/null 2>&1; then
                    if ! terraform state list 2>/dev/null | grep -qF "$RESOURCE_PATH"; then
                      echo "  üì• Importing $REPO to Terraform state..."
                      terraform import "$RESOURCE_PATH" "$REPO" || echo "Import failed for $REPO"
                    fi
                  fi
                done
                
                # Refresh state again
                terraform refresh -var-file="environments/staging.tfvars" >/dev/null 2>&1 || true
                
                # Retry apply
                echo "üîÑ Retrying apply..."
                terraform apply -auto-approve -var-file="environments/staging.tfvars" 2>&1 | tee /tmp/retry_apply_output.log
                RETRY_EXIT=${PIPESTATUS[0]}
                
                if [ $RETRY_EXIT -ne 0 ]; then
                  echo "‚ùå Retry failed!"
                  cat /tmp/retry_apply_output.log
                  exit 1
                fi
              else
                cat /tmp/apply_output.log
                exit $APPLY_EXIT
              fi
            fi
          fi
          
          echo "‚úÖ Infrastructure deployment complete"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Update ECS Services
        run: |
          echo "üîÑ Updating ECS services..."
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_BACKEND_SERVICE \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_FRONTEND_SERVICE \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ ECS updates initiated"

      - name: Wait for Deployment
        run: |
          echo "‚è≥ Waiting for services to stabilize..."
          
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_BACKEND_SERVICE \
            --region ${{ env.AWS_REGION }} \
            --max-attempts 30 && echo "‚úÖ Backend stable"

          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_FRONTEND_SERVICE \
            --region ${{ env.AWS_REGION }} \
            --max-attempts 30 && echo "‚úÖ Frontend stable"

      - name: Health Check
        run: |
          echo "üè• Running health checks..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names prodready-infra-alb-staging \
            --query 'LoadBalancers[0].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "Load Balancer: $ALB_DNS"
          
          for i in {1..10}; do
            echo "Health check $i/10..."
            if curl -f -s "http://$ALB_DNS/api/health" > /dev/null; then
              echo "‚úÖ Health check passed!"
              break
            elif [ $i -eq 10 ]; then
              echo "‚ùå Health check failed"
              exit 1
            else
              echo "‚è≥ Waiting 30s..."
              sleep 30
            fi
          done

      - name: Deployment Summary
        if: always()
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "Region: $AWS_REGION"
          echo "Commit: $GITHUB_SHA"
          echo ""
          
          if [ "${{ steps.apply.outcome }}" == "success" ]; then
            echo "Status: ‚úÖ Successful"
          else
            echo "Status: ‚ùå Failed"
          fi

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-deploy]
    if: always()
    
    steps:
      - name: Notify Success
        if: needs.build-and-deploy.result == 'success'
        run: |
          echo "üéâ Deployment Successful!"

      - name: Notify Failure
        if: needs.build-and-deploy.result == 'failure'
        run: |
          echo "‚ùå Deployment Failed!"
          exit 1