name: ProdReady_Infra CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 875486186130
  ECR_REGISTRY: 875486186130.dkr.ecr.us-east-1.amazonaws.com
  BACKEND_REPOSITORY: prodready-infra-api
  FRONTEND_REPOSITORY: prodready-infra-ui
  ECS_CLUSTER: prodready-infra-cluster-staging
  ECS_BACKEND_SERVICE: prodready-infra-backend-service-staging
  ECS_FRONTEND_SERVICE: prodready-infra-frontend-service-staging
  ENVIRONMENT: staging

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Format Check
        run: |
          cd terraform
          terraform fmt -check -recursive

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Force unlock Terraform state
        run: |
          cd terraform
          echo "üîì Force unlocking Terraform state..."
          terraform force-unlock -force ef4b274e-0c2c-cbf5-2ec5-f8e81ffd4e34 2>/dev/null || echo "No lock with this ID or already cleared"
        continue-on-error: true

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Terraform Plan
        run: |
          cd terraform
          terraform plan -var-file="environments/staging.tfvars"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend-config="environments/staging.backend.conf"

      - name: Clear stale Terraform locks
        run: |
          cd terraform
          echo "üîì Clearing any stale Terraform locks..."
          if terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep -q "Lock Info:"; then
            LOCK_ID=$(terraform plan -var-file="environments/staging.tfvars" 2>&1 | grep "ID:" | awk '{print $2}' | head -1)
            echo "Detected lock ID: $LOCK_ID"
            terraform force-unlock -force "$LOCK_ID" 2>/dev/null || echo "Could not unlock or already cleared"
          else
            echo "No locks detected"
          fi
        continue-on-error: true
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Build and push Backend image
        id: backend_image
        run: |
          cd api
          echo "üèóÔ∏è Building backend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$BACKEND_REPOSITORY:latest .
          
          echo "üì§ Pushing backend image..."
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$BACKEND_REPOSITORY:latest
          echo "‚úÖ Backend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push Frontend image
        id: frontend_image
        run: |
          cd ui
          echo "üèóÔ∏è Building frontend image..."
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%s)"
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest .
          
          echo "üì§ Pushing frontend image..."
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$FRONTEND_REPOSITORY:latest
          echo "‚úÖ Frontend image pushed"
          
          # Output for next steps
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_uri=$ECR_REGISTRY/$FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        id: apply
        run: |
          cd terraform
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve -var-file="environments/staging.tfvars"
          echo "‚úÖ Infrastructure deployment complete"
        env:
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}

      - name: Get Terraform Outputs
        id: tf_outputs
        run: |
          cd terraform
          echo "üìã Getting Terraform outputs..."
          
          # Try to get outputs, use defaults if they don't exist
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "prodready-infra-cluster-staging")
          BACKEND_SERVICE=$(terraform output -raw backend_service_name 2>/dev/null || echo "prodready-infra-backend-service-staging")
          FRONTEND_SERVICE=$(terraform output -raw frontend_service_name 2>/dev/null || echo "prodready-infra-frontend-service-staging")
          
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "backend_service=$BACKEND_SERVICE" >> $GITHUB_OUTPUT
          echo "frontend_service=$FRONTEND_SERVICE" >> $GITHUB_OUTPUT
          
          echo "Cluster: $CLUSTER_NAME"
          echo "Backend Service: $BACKEND_SERVICE"
          echo "Frontend Service: $FRONTEND_SERVICE"
        continue-on-error: false

      - name: Update Backend Task Definition
        id: backend_task_def
        run: |
          echo "üìù Updating backend task definition with new image..."
          
          TASK_FAMILY="prodready-infra-backend-task-staging"
          echo "Looking for task definition family: $TASK_FAMILY"
          
          # Check if task definition exists
          if ! aws ecs describe-task-definition --task-definition "$TASK_FAMILY" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Task definition doesn't exist yet. This is expected on first deployment."
            echo "Terraform should have created it. Waiting 30 seconds..."
            sleep 30
          fi
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --region ${{ env.AWS_REGION }})
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to get task definition after waiting"
            echo "Available task definitions:"
            aws ecs list-task-definitions --region ${{ env.AWS_REGION }} | grep -i backend || echo "No backend task definitions found"
            echo ""
            echo "This might be the first deployment. Skipping task definition update."
            echo "ECS will use the task definition created by Terraform."
            exit 0
          fi
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "${{ steps.backend_image.outputs.image_uri }}" '
            .taskDefinition |
            .containerDefinitions[0].image = $IMAGE |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION }})
          
          NEW_REVISION=$(echo "$NEW_TASK_INFO" | jq -r '.taskDefinition.revision')
          echo "‚úÖ New backend task definition revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "family=$TASK_FAMILY" >> $GITHUB_OUTPUT

      - name: Update Frontend Task Definition
        id: frontend_task_def
        run: |
          echo "üìù Updating frontend task definition with new image..."
          
          TASK_FAMILY="prodready-infra-frontend-task-staging"
          echo "Looking for task definition family: $TASK_FAMILY"
          
          # Check if task definition exists
          if ! aws ecs describe-task-definition --task-definition "$TASK_FAMILY" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Task definition doesn't exist yet. This is expected on first deployment."
            echo "Terraform should have created it. Waiting 30 seconds..."
            sleep 30
          fi
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$TASK_FAMILY" \
            --region ${{ env.AWS_REGION }})
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to get task definition after waiting"
            echo "Available task definitions:"
            aws ecs list-task-definitions --region ${{ env.AWS_REGION }} | grep -i frontend || echo "No frontend task definitions found"
            echo ""
            echo "This might be the first deployment. Skipping task definition update."
            echo "ECS will use the task definition created by Terraform."
            exit 0
          fi
          
          # Create new task definition with updated image
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "${{ steps.frontend_image.outputs.image_uri }}" '
            .taskDefinition |
            .containerDefinitions[0].image = $IMAGE |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Register new task definition
          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION }})
          
          NEW_REVISION=$(echo "$NEW_TASK_INFO" | jq -r '.taskDefinition.revision')
          echo "‚úÖ New frontend task definition revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "family=$TASK_FAMILY" >> $GITHUB_OUTPUT

      - name: Update ECS Services
        run: |
          echo "üîÑ Forcing ECS services to redeploy..."
          
          # Update backend service
          echo "Updating backend service..."
          if [ -n "${{ steps.backend_task_def.outputs.revision }}" ]; then
            aws ecs update-service \
              --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
              --service ${{ steps.tf_outputs.outputs.backend_service }} \
              --task-definition "${{ steps.backend_task_def.outputs.family }}:${{ steps.backend_task_def.outputs.revision }}" \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
          else
            echo "No new task definition, just forcing deployment"
            aws ecs update-service \
              --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
              --service ${{ steps.tf_outputs.outputs.backend_service }} \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
          fi
          
          # Update frontend service
          echo "Updating frontend service..."
          if [ -n "${{ steps.frontend_task_def.outputs.revision }}" ]; then
            aws ecs update-service \
              --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
              --service ${{ steps.tf_outputs.outputs.frontend_service }} \
              --task-definition "${{ steps.frontend_task_def.outputs.family }}:${{ steps.frontend_task_def.outputs.revision }}" \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
          else
            echo "No new task definition, just forcing deployment"
            aws ecs update-service \
              --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
              --service ${{ steps.tf_outputs.outputs.frontend_service }} \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
          fi
          
          echo "‚úÖ ECS services update initiated"

      - name: Wait for Deployment
        run: |
          echo "‚è≥ Waiting for services to stabilize (max 10 minutes)..."
          
          # Wait for backend
          echo "Waiting for backend service..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
            --services ${{ steps.tf_outputs.outputs.backend_service }} \
            --region ${{ env.AWS_REGION }} && echo "‚úÖ Backend stable" || echo "‚ö†Ô∏è Backend wait timeout"

          # Wait for frontend
          echo "Waiting for frontend service..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.tf_outputs.outputs.cluster_name }} \
            --services ${{ steps.tf_outputs.outputs.frontend_service }} \
            --region ${{ env.AWS_REGION }} && echo "‚úÖ Frontend stable" || echo "‚ö†Ô∏è Frontend wait timeout"

      - name: Health Check
        run: |
          echo "üè• Running health checks..."
          
          # Get ALB DNS from Terraform output
          cd terraform
          ALB_DNS=$(terraform output -raw lb_dns_name 2>/dev/null || echo "prodready-infra-alb-staging-212250592.us-east-1.elb.amazonaws.com")
          cd ..
          
          HEALTH_URL="http://${ALB_DNS}/api/health"
          echo "Health check URL: $HEALTH_URL"

          success=false
          for i in {1..30}; do
            echo "Attempt $i/30: Checking $HEALTH_URL"
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -m 10 "$HEALTH_URL" || echo "000")
            echo "HTTP Status: $RESPONSE"
            
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Health check passed!"
              curl -s "$HEALTH_URL" | jq '.' 2>/dev/null || curl -s "$HEALTH_URL"
              success=true
              break
            else
              echo "‚è≥ Retrying in 15 seconds..."
              sleep 15
            fi
          done

          if [ "$success" != "true" ]; then
            echo "‚ùå Health check failed after 30 attempts"
            echo "Showing recent logs..."
            
            LOG_GROUP="/ecs/prodready-infra-backend-staging"
            LATEST_STREAM=$(aws logs describe-log-streams \
              --log-group-name "$LOG_GROUP" \
              --order-by LastEventTime \
              --descending \
              --max-items 1 \
              --query 'logStreams[0].logStreamName' \
              --output text \
              --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
            
            if [ -n "$LATEST_STREAM" ] && [ "$LATEST_STREAM" != "None" ]; then
              aws logs get-log-events \
                --log-group-name "$LOG_GROUP" \
                --log-stream-name "$LATEST_STREAM" \
                --limit 50 \
                --region ${{ env.AWS_REGION }} \
                --query 'events[*].message' \
                --output text 2>/dev/null || echo "Could not fetch logs"
            fi
            
            exit 1
          fi

      - name: Deployment Summary
        if: always()
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "Region: ${{ env.AWS_REGION }}"
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "Commit: ${GITHUB_SHA:0:7}"
          echo "Backend Image: ${{ steps.backend_image.outputs.image_tag }}"
          echo "Frontend Image: ${{ steps.frontend_image.outputs.image_tag }}"
          echo ""
          if [ "${{ steps.apply.outcome }}" == "success" ]; then
            echo "Status: ‚úÖ Successful"
          else
            echo "Status: ‚ùå Failed"
          fi

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-deploy]
    if: ${{ always() }}
    
    steps:
      - name: Notify Success
        if: ${{ needs.build-and-deploy.result == 'success' }}
        run: echo "üéâ Deployment Successful!"

      - name: Notify Failure
        if: ${{ needs.build-and-deploy.result == 'failure' }}
        run: |
          echo "‚ùå Deployment Failed!"
          exit 1